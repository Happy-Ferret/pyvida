import unittest

from __init__ import *

RESOLUTION_X = 1000
RESOLUTION_Y = 1000
RESOLUTION = (RESOLUTION_X, RESOLUTION_Y)



class ActorTest(unittest.TestCase):
    def setUp(self):
        self.game = Game("Unit Tests", fps=60, afps=16, resolution=RESOLUTION)
        self.game.settings = Settings()
        self.actor = Actor("_test_actor").smart(self.game)
        self.game.add(self.actor)

    def test_initial_xy(self):
        self.assertEqual(self.actor.x, 0)
        self.assertEqual(self.actor.y, 0)

    def test_locations(self):
        self.actor.x, self.actor.y = 100,100
        self.assertEqual(self.actor.x, 100)
        self.assertEqual(self.actor.y, 100)
        self.actor.pyglet_draw()
        self.assertEqual(self.actor._sprite.x, 100)
        self.assertEqual(self.actor._sprite.y, RESOLUTION_Y - self.actor.y - self.actor._sprite.height)

    def test_anchor(self):
        self.actor.x, self.actor.y = 100,100
        self.actor._ax, self.actor._ay = -25, -100
        self.assertEqual(self.actor._ax, -25)
        self.assertEqual(self.actor._ay, -100)

        self.actor.ax, self.actor.ay = 75, 0
        self.assertEqual(self.actor._ax, -25)
        self.assertEqual(self.actor._ay, -100)
        
        self.actor.pyglet_draw()
        self.assertEqual(self.actor._sprite.x, 75)
        self.assertEqual(self.actor._sprite.y, RESOLUTION_Y - self.actor.y - self.actor._sprite.height - self.actor.ay)


    def test_clickable_area(self):
        self.assertEqual(self.actor.clickable_area.w, 100)
        self.assertEqual(self.actor.clickable_area.h, 100)
        self.actor.x, self.actor.y = 100,100
        self.assertEqual(self.actor.clickable_area.x, 100)
        self.assertEqual(self.actor.clickable_area.y, 100)


    def test_clickable_mask(self):
        self.actor._clickable_area = Rect(0,0,100,100)

        #autogenerated mask should match clickable area
        self.assertEqual(self.actor.clickable_mask.width, 100)
        self.assertEqual(self.actor.clickable_mask.height, 100)

        self.assertFalse(self.actor.collide(-200,-200)) #miss
        self.assertTrue(self.actor.collide(0,0)) #hit
        self.assertTrue(self.actor.collide(50,50)) #hit
        self.assertFalse(self.actor.collide(200,200)) #miss
        self.assertFalse(self.actor.collide(300,300)) #miss


        #using reclickable resets the mask

        self.actor.on_reclickable(Rect(50,50,200,200))
        self.assertEqual(self.actor.clickable_mask.width, 200)
        self.assertEqual(self.actor.clickable_mask.height, 200)
        
        self.assertFalse(self.actor.collide(0,0)) #miss
        self.assertTrue(self.actor.collide(50,50)) #hit
        self.assertTrue(self.actor.collide(200,200)) #hit
        self.assertFalse(self.actor.collide(300,300)) #miss

    def test_debug_draw(self):
        self.actor.x, self.actor.y = 100,100
        self.actor._ax, self.actor._ay = -25, -100
        self.actor.show_debug = True
        self.actor.pyglet_draw() #will also draw debugs now
        self.assertEqual(len(self.actor._debugs), 3)
        position, anchor, clickable_area = self.actor._debugs
        self.assertEqual(position, (100, 100))
        self.assertEqual(anchor, (75, 0))

    def test_debug_draw_clickable(self):
        self.actor.x, self.actor.y = 100,100
        self.actor.show_debug = True
        self.actor.pyglet_draw() #will also draw debugs now
        position, anchor, clickable_area = self.actor._debugs
        self.assertEqual(clickable_area, [(100, 900), (200, 900), (200, 800), (100, 800)])

    def test_smart_using(self):
        msgbox = Item("msgbox").smart(self.game, using="data/items/_test_item")
        self.assertEqual(msgbox.name, "msgbox")
        self.assertEqual(msgbox.action.name, "idle")
        self.assertEqual(msgbox.w, 100)


class GameEventsTest(unittest.TestCase):
    def setUp(self):
        self.game = Game("Unit Tests", fps=60, afps=16, resolution=RESOLUTION)
        self.game.settings = Settings()
        self.actor = Actor("_test_actor").smart(self.game)
        self.msgbox = Item("msgbox").smart(self.game, using="data/actors/_test_actor")
        self.ok = Item("ok").smart(self.game, using="data/actors/_test_actor")
        self.scene = Scene("_test_scene")
        self.game.add([self.scene, self.actor, self.msgbox, self.ok])

    def test_relocate(self):
        self.actor.relocate(self.scene)
        event = self.game._events[0]
        self.assertEqual(len(self.game._events), 1)
        self.assertEqual(event[0].__name__, "on_relocate")
        self.assertEqual(event[1][0], self.actor)
        self.assertEqual(event[1][1], self.scene)

    def test_on_says_using(self):
        self.actor.says("Hello World", using="data/items/_test_item", ok=False)
        self.assertEqual(len(self.game._events), 1)
        event = self.game._events[0]
        self.assertEqual(self.game._event, None)
        self.assertEqual(event[0].__name__, "on_says")
        self.assertEqual(event[1][0], self.actor)
        self.assertEqual(event[1][1], "Hello World")
        self.game.update(0)
        event = self.game._events[0]


    def test_event_ordering(self):
        self.actor.says("Hello World")
        self.actor.says("Goodbye World")
        events = self.game._events
        self.assertEqual(events[0][1][1], "Hello World")
        self.assertEqual(events[1][1][1], "Goodbye World")


    def test_on_says_events(self):
        self.actor.says("Hello World", using="data/items/_test_item", ok=False)
        self.actor.says("Goodbye World", using="data/items/_test_item", ok=False)

        self.game.update(0) #start the first on_says
        self.assertEqual(self.game._event_index, 1)
        self.assertEqual(self.game._waiting, True)
        self.assertEqual(self.actor._busy, True)
        self.assertEqual(len(self.game._modals), 2)

        self.game.update(0) #should still be blocking as user has done nothing

        self.assertEqual(self.game._event_index, 1)
        self.assertEqual(self.game._waiting, True)
        self.assertEqual(self.actor._busy, True)
        self.assertEqual(len(self.game._modals), 2)

        #finish the on_says event, the next on_says should not have started yet

        self.game._modals[0].trigger_interact() #finish the on says

        self.assertEqual(len(self.game._modals), 0) #should be gone
        self.assertEqual(self.actor._busy, False) #actor should be free
        self.assertEqual(self.game._event_index, 1) #still on first event
        self.assertEqual(self.game._waiting, True) #game still waiting

        self.game.update(0) #trigger the next on_says, everything should be waiting again

        self.assertEqual(self.game._event_index, 2)
        self.assertTrue(self.game._waiting)
        self.assertTrue(self.actor._busy)
        self.assertEqual(len(self.game._modals), 2)

        self.game._modals[0].trigger_interact() #finish the on says

        self.assertEqual(len(self.game._modals), 0)
        self.assertEqual(len(self.game._events), 0)
        



if __name__ == '__main__':
    unittest.main()
